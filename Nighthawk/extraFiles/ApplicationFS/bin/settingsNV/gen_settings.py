#!/usr/bin/env python3
#*****************************************************************************
#    Copyright (c) 2019 Fluke Corporation, Inc. All rights reserved.
#*****************************************************************************
#
#   Repository URL:    <URL to Containing Repository>
#   Authored By:        Seth Kramer
#   Origin:             Nighthawk
#*****************************************************************************

import json
import traceback

#*  Constants ****************************************************************
OUTPUT_FILE_PATH = "../../shared/utils"

ENUM_NAME_KEY = "name"
DEFAULT_KEY = "factoryDefault"
REGEX_KEY = "regex"
REGEX_VALIDATOR_KEY = "regexvalidator"

# Include guards
IG_SETTINGS_GEN_ENUM = "_SETTINGS_GEN_ENUM_H"
IG_SETTINGS_QT_GEN_ENUM = "_SETTINGS_QT_GEN_ENUM_H"
IG_SETTINGS_GEN_ENUM_T = "_SETTINGS_GEN_ENUM_T_H"
IG_SETTINGS_QT_GEN_ENUM_T = "_SETTINGS_QT_GEN_ENUM_T_H"

FILE_HEADER = """//////////////////////////////////////////////////////////////////////////////
/*
    Copyright (c) 2019 Fluke Corporation, Inc. All rights reserved.
    Use of the software source code and warranty disclaimers are
    identified in the Software Agreement associated herewith.

    Repository URL:     git.sesg.fluke.com:/fcal/nighthawk/sw/src.git
    Authored By:        gen_settings.py
    Origin:             Nighthawk
*/

/** @file
    This file is generated by gen_settings.py; do not make changes!!!
    Instead, implement changes in systemsettings.json and run
    /usr/bin/python3 gen_settings.py
*/

#ifndef {0}
#define {0}
"""

FILE_FOOTER = """#endif // {0}

// END OF FILE ///////////////////////////////////////////////////////////////
"""

#*  Classes ******************************************************************
class EnumValue:
    def __init__(self, name, string_representation):
        self.name = name
        self.string_representation = string_representation

class Setting:
    def __init__(self, class_name, enum_name, default, enum_values):
        self.class_name = class_name
        self.enum_name = enum_name
        self.default = default
        self.enum_values = enum_values

def is_enum_setting(setting):
    return REGEX_VALIDATOR_KEY in setting

def generate_indent(indent_level):
    result = ""

    for _ in range(indent_level):
        result += "\t"

    return result

# Expected name is in the format: "NAME_TO_CONVERT" with underscores seperating words.
# Result from example above: "NameToConvert"
def convert_to_pascal_case(name):
    return name.replace("_", " ").title().replace(" ", "")

def create_settings(raw_settings_list):
    result_list = []

    # Remove non-enum settings
    raw_settings_list = [setting for setting in raw_settings_list if is_enum_setting(setting)]

    # Loop through the enum settings extracting values from keys
    for setting in raw_settings_list:

        # Capture enum name and default value
        enum_name = setting[ENUM_NAME_KEY].upper()
        class_name = convert_to_pascal_case(enum_name)
        default = setting[DEFAULT_KEY].upper()

        # Retrieve the enum possible values
        regex_from_setting = setting[REGEX_VALIDATOR_KEY][REGEX_KEY]

        # Strip regex prefix and suffix characters
        regex_from_setting = regex_from_setting.strip("^()$")
        split_regex = regex_from_setting.split("|")

        enum_values = []
        for regex in split_regex:
            value = regex.strip("^$")

            # Check if its a square bracket value, and if so, split
            if (value[0] == "[") and (value[-1] == "]"):
                value = value.strip("[]")

                for character in value:
                    enum_values.append(EnumValue(character.upper(), character))

            else:
                enum_values.append(EnumValue(value.upper(), value))

        result_list.append(Setting(class_name, enum_name, default, enum_values))

    return result_list

def create_settings_header(settings):
    with open("{}/settings_gen_enum.h".format(OUTPUT_FILE_PATH), "w+") as out_file:
        out_file.write(FILE_HEADER.format(IG_SETTINGS_GEN_ENUM))
        out_file.write("\n\n")

        for setting in settings:
            write_enum_def_from_setting(out_file, setting, make_class=True)
            out_file.write("\n")

        out_file.write("\n")
        out_file.write(FILE_FOOTER.format(IG_SETTINGS_GEN_ENUM))

def create_qt_settings_header(settings):
    with open("{}/settings_qt_gen_enum.h".format(OUTPUT_FILE_PATH), "w+") as out_file:
        out_file.write(FILE_HEADER.format(IG_SETTINGS_QT_GEN_ENUM))
        out_file.write("\n")
        out_file.write("#include <QObject>\n\n\n")

        for setting in settings:
            out_file.write("class {}\n".format(setting.class_name))
            out_file.write("{\n")
            out_file.write("\tQ_GADGET\n")
            out_file.write("\tQ_ENUMS({})\n".format(setting.enum_name))
            out_file.write("public:\n")
            write_enum_def_from_setting(out_file, setting, make_class=False, indent_level=1)
            out_file.write("};\n")
            out_file.write("Q_DECLARE_METATYPE({}::{})\n\n".format(setting.class_name, setting.enum_name))

        out_file.write("\n")
        out_file.write(FILE_FOOTER.format(IG_SETTINGS_QT_GEN_ENUM))

def create_enum_t_header(create_qt_header, settings):
    output_file_name = "settings_qt_gen_enum_t.h" if create_qt_header else "settings_gen_enum_t.h"
    include_guard = IG_SETTINGS_QT_GEN_ENUM_T if create_qt_header else IG_SETTINGS_GEN_ENUM_T
    setting_enum_include = "settings_qt_gen_enum.h" if create_qt_header else "settings_gen_enum.h"

    with open("{}/{}".format(OUTPUT_FILE_PATH, output_file_name), "w+") as out_file:
        out_file.write(FILE_HEADER.format(include_guard))
        out_file.write("\n")

        # Write the include
        out_file.write("#include \"utils/EnumT.h\"\n")
        out_file.write("#include \"utils/{}\"\n\n\n".format(setting_enum_include))

        out_file.write("namespace utils {\n\n")

        for setting in settings:
            class_name = "{}::{}".format(setting.class_name, setting.enum_name) if create_qt_header else setting.enum_name

            out_file.write("template <> const std::string EnumT<{}>::m_enumName{{\"{}\"}};\n".format(class_name, setting.enum_name))
            out_file.write("template <> const {0} EnumT<{0}>::m_defaultValue{{{0}::{1}}};\n".format(
                class_name, setting.default))
            write_enum_t_map(out_file, class_name, setting)
            out_file.write("\n")

        out_file.write("}\n\n")
        out_file.write(FILE_FOOTER.format(include_guard))

def write_enum_def_from_setting(out_file, setting, make_class, indent_level=0):
    first_line = True
    indent = generate_indent(indent_level)
    enum_def = "enum class" if make_class else "enum"

    out_file.write("{}{} {}\n".format(indent, enum_def, setting.enum_name))
    out_file.write("{}{{\n".format(indent))

    for value in setting.enum_values:
        if not first_line:
            out_file.write(",\n")
        else:
            first_line = False

        out_file.write("{}\t{}".format(indent, value.name))

    out_file.write("\n{}}};\n".format(indent))

def write_enum_t_map(out_file, class_name, setting):
    first_line = True

    out_file.write("template <> const std::map<{0}, std::string> EnumT<{0}>::m_valueNameMap\n".format(class_name))
    out_file.write("{\n")

    # Loop through the enum values creating the map
    for value in setting.enum_values:
        if not first_line:
            out_file.write(",\n")
        else:
            first_line = False

        out_file.write("\t{{ {}::{}, \"{}\" }}".format(
            class_name,
            value.name,
            value.string_representation))

    out_file.write("\n};\n")


def main():
    try:
        raw_settings_list = []

        with open("systemsettings.json") as in_file:
            raw_settings_list = json.load(in_file)

        # Create settings list from raw json data
        settings = create_settings(raw_settings_list)

        # Create the autogenerated files
        create_settings_header(settings)
        create_qt_settings_header(settings)
        create_enum_t_header(False, settings)
        create_enum_t_header(True, settings)

    except Exception as e:
        print("Error: {}".format(e))
        print(traceback.format_exc())

if __name__ == "__main__":
    main()
